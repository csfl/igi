package node

import (
	"encoding/hex"
	"strings"
	"testing"
)

const msgHex = `00000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000a6f3cc54be36
beb6982ca4419b2ecd6c71066c90fff39beb6546e5ceff5f97d0d39fddfaa931034a26134974c9
c8244e0300000000000000000000000000000000601e040000000000000000000000000033b1d4
4a01000000000000010000000000b351faf86a645f626c8c6250c5d3bb35ffbbe51aa44aaf5c91
93f055a117276e79da914c39b8492544a8115f23b818203bd1281b5ed8b3d5ac19b8fe44067722
adf20ed78d279bb8ff271916d364f3eccfcbde57dc92b19101896dc23118000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
0000002d5b0c000000000000000000000000003f5ccc5017100000000000240000000036c0768d
19052305230a22e871f34a39fc70915096f6950508089bc48a3431f705c649a44c9fec13062f30
1636fb1bacc589dd30c34a42a98750eace90788a`

func msgBytes() []byte {
	s := strings.Replace(msgHex, "\n", "", -1)
	b, err := hex.DecodeString(s)
	if err != nil {
		panic(err)
	}
	return b
}

func TestParseUdpBytes(t *testing.T) {
	b := msgBytes()
	msg, err := ParseUdpBytes(b)

	// TODO: use message with all fields filled, this is suboptimal with zero values

	if err != nil {
		t.Fatal(err)
	}
	if msg == nil {
		t.Fatal(msg)
	}
	if v := msg.AddressTrytes(); v != `XNZBYAST9BETSDNOVQKKTBECYIPMF9IPOZRWUPFQGVH9HJW9NDSQVIPVBWU9YKECRYGDSJXYMZGHZDXCA` {
		t.Fatal(v)
	}
	if v := msg.BundleTrytes(); v != `9DX9JZSIHDKNVFALSNFYIVYLHSZT9IS9QIUQTC9EJXNREYDLVNCLSJMMPZQKHCBCBHJSWGQQSEYDIXHOD` {
		t.Fatal(v)
	}
	if v := msg.TrunkTrytes(); v != `EKKKD9JDPWDOMQRYACT9NCBFMGJZKYNJMENLJTZSZ9MUCVALBKNITOVAPPRJRHQERXE9UNAMFKEXA9999` {
		t.Fatal(v)
	}
	if v := msg.BranchTrytes(); v != `999999999999999999999999999999999999999999999999999999999999999999999999999999999` {
		t.Fatal(v)
	}
	if v := msg.ObsoleteTagTrytes(); v != `ODJL99999999999999999999999` {
		t.Fatal(v)
	}
	if v := msg.TagTrytes(); v != `ODJL99999999999999999999999` {
		t.Fatal(v)
	}
	if v := msg.Value; v != 0 {
		t.Fatal(v)
	}
	if v := msg.CurrentIndex; v != 0 {
		t.Fatal(v)
	}
	if v := msg.LastIndex; v != 1 {
		t.Fatal(v)
	}
	if v := msg.Ts; v != 1515328739 {
		t.Fatal(v)
	}
	if v := msg.AttachmentTs; v != 1515328739638 {
		t.Fatal(v)
	}
	if v := msg.AttachmentTsLower; v != 0 {
		t.Fatal(v)
	}
	if v := msg.AttachmentTsUpper; v != 12 {
		t.Fatal(v)
	}
}
